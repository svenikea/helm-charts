{{ if .Values.externalSecret.enabled }}
---
apiVersion: external-secrets.io/v1
kind: SecretStore
metadata:
  name: {{ .Values.deployment.name }}-secret-store
spec:
  provider:
  {{ if .Values.externalSecret.onepassword.connectServer }}
    onepassword:
      connectHost: {{ .Values.externalSecret.onepassword.connectHost }}
      vaults:
        {{ .Values.externalSecret.onepassword.vaultName }}: 1
      auth:
        secretRef:
          connectTokenSecretRef:
            name: {{ .Values.externalSecret.onepassword.tokenName | default "op-credentials" }}
            key: {{ .Values.externalSecret.onepassword.tokenKey | default "token" }}
            namespace: {{ .Release.Namespace }}
  {{ end }}
  {{ if .Values.externalSecret.onepassword.sdk }}
    onepasswordSDK:
      vault: {{ .Values.externalSecret.onepassword.vaultName }}
      auth:
        serviceAccountSecretRef:
          name: {{ .Values.externalSecret.onepassword.tokenName | default "op-credentials" }}
          key: {{ .Values.externalSecret.onepassword.tokenKey | default "token" }}
      integrationInfo: # this is optional and defaulted
        name: integration-info
        version: v1
  {{ end }}
  {{ if and .Values.externalSecret.onepassword.connectServer .Values.externalSecret.onepassword.sdk }}
  {{ fail "Only one of externalSecret.onepassword.connectServer or externalSecret.onepassword.sdk can be enabled at the same time!" }}
  {{ end }}
{{- /*
################## Attention ###############################
# Please the the kube command like this to create the
# 1password token secret after the argo application is
# created:
# kubectl create secret generic op-credentials \
# --from-literal=token="<token-here>" -n <namespace-here>
############################################################
*/}}
---
apiVersion: external-secrets.io/v1
kind: ExternalSecret
metadata:
  name: {{ .Values.deployment.name }}-secret-fetcher
spec:
  refreshInterval: 1h
  secretStoreRef:
    kind: SecretStore
    name: {{ .Values.deployment.name }}-secret-store
  target:
    creationPolicy: Owner
  data:
    {{- /*
    # Splits the multiline string into lines.
    # Removes whitespace
    # Ensures blank lines are skipped
    */}}
    {{ range $name := splitList "\n" .Values.externalSecret.onepassword.data }}
    {{ $trimmed := trim $name }}
    {{ if $trimmed }}
      - secretKey: {{ $trimmed }}
        remoteRef:
          key: {{ $.Values.externalSecret.onepassword.item }}/{{ $trimmed }}
    {{ end }}
    {{ end }}
    {{- /*
    # Get Specific values from 1Password
    */}}
    {{ range .Values.externalSecret.onepassword.secretLists }}
      - secretKey: {{ .name }}
        remoteRef:
          key: {{ $.Values.externalSecret.onepassword.item }}/{{ .name }}
    {{ end }}
{{ end }}

{{ if .Values.externalSecret.privateRegistry.enabled }}
---
apiVersion: external-secrets.io/v1
kind: ExternalSecret
metadata:
  name: {{ .Values.deployment.name }}-private-registry-secret-fetcher
spec:
  refreshInterval: 1h
  secretStoreRef:
    kind: SecretStore
    name: {{ .Values.deployment.name }}-secret-store
  target:
    creationPolicy: Owner
    template:
      type: kubernetes.io/dockerconfigjson
      data:
        .dockerconfigjson: '{"auths":{"registry.volcanly.me":{"username": "{{ "{{" }}.username{{ "}}" }}","password": "{{ "{{" }}.password{{ "}}" }}"}}}'
  data:
    - secretKey: username
      remoteRef:
        key: {{ $.Values.externalSecret.privateRegistry.onepasswordItem | default "Harbor Robot" }}/username
    - secretKey: password
      remoteRef:
        key: {{ $.Values.externalSecret.privateRegistry.onepasswordItem | default "Harbor Robot" }}/password
{{ end }}
